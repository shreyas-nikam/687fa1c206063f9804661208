
# Streamlit Application Requirements Specification: Crypto Operational Loss Mitigation Simulator

This document outlines the requirements for developing a Streamlit application based on the provided Jupyter notebook content and user specifications. It will serve as a blueprint for implementing the interactive components and integrating the core logic.

## 1. Application Overview

The **Crypto Operational Loss Mitigation Simulator** application aims to provide an interactive platform for simulating operational loss events within a hypothetical cryptocurrency exchange environment. Its primary objective is to demonstrate and analyze the financial impact of different insurance-like mitigation strategies, such as self-insurance funds or traditional excess-of-loss policies.

**Purpose and Objectives:**
*   To enable users to define parameters for simulating operational loss events (e.g., frequency, severity distribution).
*   To allow configuration of mitigation policy parameters, including deductible ($d$) and cover ($c$) per loss event.
*   To simulate loss events and calculate gross losses, transferred losses (payouts), and retained losses.
*   To visualize the effectiveness of various mitigation strategies through interactive charts and aggregated summaries.
*   To help risk managers, financial analysts, and students understand and apply concepts from operational risk management to digital asset platforms, specifically demystifying the effect of insurance mitigation as described in the `PRMIA Operational Risk Manager Handbook` [7], [8].

## 2. User Interface Requirements

The application will feature a clear, intuitive layout designed for interactive exploration of operational risk mitigation.

**Layout and Navigation Structure:**
*   **Sidebar for Controls**: All input parameters (simulation settings, policy details) will be placed in a collapsible sidebar to keep the main content area focused on results and visualizations.
*   **Main Content Area**: The primary display area will sequentially present:
    *   An overview and explanatory text.
    *   Tables with simulated loss data and descriptive statistics.
    *   Interactive visualizations (payout function, cumulative losses, relationship plots, aggregated comparisons).
    *   Aggregated financial summaries.
*   **Sections**: The main area will be logically divided using headings and possibly `st.expander` for better organization and user experience.

**Input Widgets and Controls:**
Users will interact with the application primarily through numeric inputs, sliders, and dropdowns.
*   **Simulation Parameters (in Sidebar):**
    *   **Number of Events**: `st.slider` or `st.number_input` for `num_events` (e.g., 100 to 5000 events, with a default of 1000).
    *   **Loss Severity Distribution Type**: `st.selectbox` for `distribution_type` (options: 'Lognormal', 'Pareto', 'Exponential').
    *   **Distribution Parameters**: Dynamic `st.number_input` widgets will appear based on the selected `distribution_type`:
        *   **Lognormal**: `mu` (mean of log), `sigma` (std dev of log).
        *   **Pareto**: `xm` (minimum value), `alpha` (shape parameter).
        *   **Exponential**: `lambda_` (rate parameter).
    *   **Help Text**: Inline help text or tooltips (`st.info` or `st.help`) will describe each parameter.
*   **Mitigation Policy Parameters (in Sidebar):**
    *   **Deductible ($d$)**: `st.number_input` or `st.slider` for the deductible amount (e.g., $100,000 to $10,000,000, default $1,000,000).
    *   **Cover ($c$)**: `st.number_input` or `st.slider` for the maximum cover per event (e.g., $100,000 to $10,000,000, default $5,000,000).
    *   **Help Text**: Inline help text or tooltips (`st.info` or `st.help`) will describe these policy terms.

**Visualization Components:**
*   **Simulated Loss Data Table**: Display the first few rows of the `simulated_losses_df` and its descriptive statistics (`.describe()`) using `st.dataframe` or `st.write`.
*   **Payout Function Visualizer**: An interactive Plotly line chart generated by `plot_payout_function`.
    *   X-axis: Gross Loss; Y-axis: Amount.
    *   Lines: 'Payout' and 'Retained Loss'.
    *   **Interactivity**: Hover-over tooltips to display exact values.
*   **Cumulative Losses Trend Plot**: A Matplotlib line plot generated by `plot_cumulative_losses`.
    *   X-axis: Event Number; Y-axis: Cumulative Loss.
    *   Lines: 'Cumulative Gross Loss' and 'Cumulative Retained Loss'.
    *   **Style**: Color-blind-friendly palette, font size $\ge 12$ pt, clear title, labeled axes, legend, and grid.
*   **Gross Loss vs. Transferred Loss Relationship Plot**: A Matplotlib scatter plot generated by `plot_relationship`.
    *   X-axis: Gross Loss; Y-axis: Transferred Loss (Payout).
    *   **Style**: Color-blind-friendly palette, font size $\ge 12$ pt, clear title, labeled axes, and grid.
*   **Aggregated Loss Comparison Bar Chart**: A Matplotlib bar chart generated by `plot_aggregated_comparison`.
    *   X-axis: Loss Category (Gross, Transferred, Retained); Y-axis: Total Amount.
    *   **Style**: Color-blind-friendly palette, font size $\ge 12$ pt, clear title, labeled axes, and tight layout.
*   **Aggregated Loss Summary**: Display the `aggregated_loss_data` dictionary contents using `st.metric` or `st.write` for a clear financial overview.

**Interactive Elements and Feedback Mechanisms:**
*   All charts and summary statistics will dynamically update in real-time as users adjust input parameters.
*   Error messages or warnings (`st.error`, `st.warning`) will be displayed for invalid inputs (e.g., missing distribution parameters).
*   Clear titles, axis labels, and legends will be provided for all visualizations to ensure clarity and usability.

## 3. Additional Requirements

**Real-time Updates and Responsiveness:**
*   The application must re-run calculations and update all displayed outputs (tables, charts, aggregated data) instantaneously upon changes to any input parameter.
*   The entire simulation and visualization process should complete within 5 minutes on a mid-spec laptop (8 GB RAM), even for maximum `num_events`.

**Annotation and Tooltip Specifications:**
*   Every input widget will have associated help text or tooltips explaining its purpose and the meaning of its parameters.
*   Plotly charts will inherently support interactive tooltips on hover to reveal specific data points.
*   Matplotlib plots will include clear labels and legends.

## 4. Notebook Content and Code Requirements

This section details how the core logic and functions from the Jupyter notebook will be integrated into the Streamlit application. All necessary functions will be imported or defined within the Streamlit application script.

**4.1. Setup and Installations**
*   **Libraries**: The Streamlit application will require `pandas`, `numpy`, `matplotlib`, and `plotly`. These should be listed in a `requirements.txt` file for deployment.

**4.2. Simulating Operational Loss Events**
*   **Function**: `simulate_loss_events(num_events, distribution_type, **params)`
*   **Purpose**: Generates a DataFrame of hypothetical operational loss events with `timestamp` and `gross_loss` columns.
*   **Streamlit Integration**:
    *   **Input Controls**: Use `st.number_input` or `st.slider` for `num_events` in the sidebar. Use `st.selectbox` for `distribution_type`.
    *   **Conditional Inputs**: Based on `distribution_type` selection, display relevant `st.number_input` widgets for `params`:
        *   **Lognormal**: `mu`, `sigma`.
            *   **Formula**: The probability density function is given by:
                $$ f(x | \mu, \sigma) = \frac{1}{x\sigma\sqrt{2\pi}} e^{-\frac{(\ln x - \mu)^2}{2\sigma^2}} $$
        *   **Pareto**: `xm`, `alpha`.
            *   **Formula**: Its probability density function (Type I) is:
                $$ f(x | x_m, \alpha) = \frac{\alpha x_m^\alpha}{x^{\alpha+1}} \quad \text{for } x \ge x_m $$
        *   **Exponential**: `lambda_`.
            *   **Formula**: Its probability density function is:
                $$ f(x | \lambda) = \lambda e^{-\lambda x} \quad \text{for } x \ge 0 $$
    *   **Code Reference**:
        ```python
        import pandas as pd
        import numpy as np

        def simulate_loss_events(num_events, distribution_type, **params):
            """Generates gross loss values based on a specified distribution."""
            if distribution_type == 'Lognormal':
                try:
                    mu = params['mu']
                    sigma = params['sigma']
                    gross_loss = np.random.lognormal(mean=mu, sigma=sigma, size=num_events)
                except KeyError as e:
                    raise ValueError(f"Missing parameter: {e}")
                except TypeError:
                    raise TypeError("Invalid parameter type.")
            elif distribution_type == 'Pareto':
                try:
                    xm = params['xm']
                    alpha = params['alpha']
                    gross_loss = (np.random.pareto(alpha, num_events) + 1) * xm
                except KeyError as e:
                    raise ValueError(f"Missing parameter: {e}")
                except TypeError:
                    raise TypeError("Invalid parameter type.")
            elif distribution_type == 'Exponential':
                try:
                    lambda_ = params['lambda']
                    gross_loss = np.random.exponential(scale=1/lambda_, size=num_events)
                except KeyError as e:
                    raise ValueError(f"Missing parameter: {e}")
                except TypeError:
                    raise TypeError("Invalid parameter type.")
            else:
                raise ValueError("Invalid distribution type.")

            df = pd.DataFrame({
                'timestamp': pd.to_datetime(np.random.choice(pd.date_range('2023-01-01', '2023-12-31'), size=num_events)),
                'gross_loss': gross_loss
            })
            return df
        ```
    *   **Output Display**: After simulation, display `simulated_losses_df.head()` using `st.dataframe` and `simulated_losses_df['gross_loss'].describe()` using `st.write`.

**4.3. Calculating Payout (Transferred Loss)**
*   **Function**: `calculate_payout(gross_loss_series, deductible, cover)`
*   **Purpose**: Calculates the amount of loss transferred based on gross loss, deductible, and cover.
*   **Streamlit Integration**:
    *   **Input Controls**: `st.number_input` or `st.slider` for `deductible` and `cover` in the sidebar.
    *   **Calculation**: This function will be called internally to add a `transferred_loss` column to the `simulated_losses_df`.
    *   **Formula**: The payout function, $L_{d,c}(X_i)$, is defined as:
        $$ L_{d,c}(X_i) = \min(\max(X_i - d, 0), c) $$
    *   **Code Reference**:
        ```python
        import pandas as pd

        def calculate_payout(gross_loss_series, deductible, cover):
            """Calculates the transferred loss (payout)."""
            payout = (gross_loss_series - deductible).clip(lower=0)
            payout = payout.clip(upper=cover)
            return payout
        ```

**4.4. Calculating Retained Loss**
*   **Function**: `calculate_retained_loss(gross_loss_series, payout_series)`
*   **Purpose**: Calculates the portion of gross loss retained by subtracting the payout.
*   **Streamlit Integration**:
    *   **Calculation**: This function will be called internally to add a `retained_loss` column to the `simulated_losses_df`.
    *   **Formula**:
        $$ \text{Retained Loss} = \text{Gross Loss} - \text{Payout} $$
    *   **Code Reference**:
        ```python
        import pandas as pd

        def calculate_retained_loss(gross_loss_series, payout_series):
            """Calculates the retained loss by subtracting the payout from the gross loss."""
            return gross_loss_series - payout_series
        ```

**4.5. Aggregating Losses**
*   **Function**: `aggregate_losses(dataframe)`
*   **Purpose**: Sums up `gross_loss`, `transferred_loss`, and `retained_loss` from the DataFrame.
*   **Streamlit Integration**:
    *   **Calculation**: This function will be called after all loss calculations are complete.
    *   **Output Display**: Display the returned dictionary in the main content area using `st.metric` or `st.write` for clear, summarized financial figures.
    *   **Formula**: The aggregate net risk, $S_{net}$, after mitigation is calculated as:
        $$ S_{net} = \sum_{i=1}^{N} X_i - \sum_{i=1}^{N} L_{d,c}(X_i) $$
        This is equivalent to summing the individual retained losses:
        $$ S_{net} = \sum_{i=1}^{N} (X_i - L_{d,c}(X_i)) = \sum_{i=1}^{N} \text{Retained Loss}_i $$
    *   **Code Reference**:
        ```python
        import pandas as pd

        def aggregate_losses(dataframe):
                        """Calculates aggregated losses from the DataFrame."""

                        gross_loss = dataframe['gross_loss'].sum()
                        transferred_loss = dataframe['transferred_loss'].sum()
                        retained_loss = dataframe['retained_loss'].sum()

                        return {
                            'gross_loss': float(gross_loss),
                            'transferred_loss': float(transferred_loss),
                            'retained_loss': float(retained_loss)
                        }
        ```

**4.6. Visualizing the Payout Function**
*   **Function**: `plot_payout_function(deductible, cover)`
*   **Purpose**: Generates an interactive Plotly graph illustrating the payout function.
*   **Streamlit Integration**:
    *   **Display**: Render the Plotly figure using `st.plotly_chart()`.
    *   **Formulae**:
        *   Payout: $ \text{Payout} = \min(\max(\text{Gross Loss} - d, 0), c) $
        *   Retained Loss: $ \text{Retained Loss} = \text{Gross Loss} - \text{Payout} $
    *   **Code Reference**:
        ```python
        import numpy as np
        import plotly.graph_objects as go

        def plot_payout_function(deductible, cover):
            """Generates an interactive plot visualizing the payout function."""
            gross_loss_range = np.linspace(0, deductible + cover + 2000, 500)
            payout = np.minimum(np.maximum(gross_loss_range - deductible, 0), cover)
            retained_loss = gross_loss_range - payout

            fig = go.Figure()
            fig.add_trace(go.Scatter(x=gross_loss_range, y=payout, mode='lines', name='Payout'))
            fig.add_trace(go.Scatter(x=gross_loss_range, y=retained_loss, mode='lines', name='Retained Loss'))
            fig.update_layout(
                title='Payout Function',
                xaxis_title='Gross Loss',
                yaxis_title='Amount',
                hovermode='x unified'
            )
            return fig # Return figure object for Streamlit
        ```

**4.7. Visualizing Cumulative Losses (Trend Plot)**
*   **Function**: `plot_cumulative_losses(dataframe)`
*   **Purpose**: Generates a Matplotlib line plot showing cumulative gross and retained losses.
*   **Streamlit Integration**:
    *   **Display**: Render the Matplotlib figure using `st.pyplot()`.
    *   **Code Reference**:
        ```python
        import pandas as pd
        import matplotlib.pyplot as plt

        def plot_cumulative_losses(dataframe):
            """Generates a trend plot showing the cumulative gross and net losses."""
            cumulative_gross_loss = dataframe['gross_loss'].cumsum()
            cumulative_retained_loss = dataframe['retained_loss'].cumsum()

            fig, ax = plt.subplots(figsize=(10, 6)) # Use subplots for Streamlit
            ax.plot(cumulative_gross_loss, label='Cumulative Gross Loss')
            ax.plot(cumulative_retained_loss, label='Cumulative Retained Loss')

            ax.set_xlabel('Event Number')
            ax.set_ylabel('Cumulative Loss')
            ax.set_title('Cumulative Gross and Retained Losses Over Events')
            ax.legend()
            ax.grid(True)
            return fig # Return figure object for Streamlit
        ```

**4.8. Visualizing the Relationship between Gross Loss and Transferred Loss**
*   **Function**: `plot_relationship(dataframe)`
*   **Purpose**: Creates a Matplotlib scatter plot of gross loss versus transferred loss.
*   **Streamlit Integration**:
    *   **Display**: Render the Matplotlib figure using `st.pyplot()`.
    *   **Code Reference**:
        ```python
        import pandas as pd
        import matplotlib.pyplot as plt

        def plot_relationship(dataframe):
            """Generates a scatter plot of gross loss vs. transferred loss."""
            if not {'gross_loss', 'transferred_loss'}.issubset(dataframe.columns):
                raise KeyError("DataFrame must contain 'gross_loss' and 'transferred_loss' columns.")
            if not pd.api.types.is_numeric_dtype(dataframe['gross_loss']) or not pd.api.types.is_numeric_dtype(dataframe['transferred_loss']):
                raise TypeError("Columns 'gross_loss' and 'transferred_loss' must be numeric.")
            if dataframe.empty:
                # Handle empty dataframe gracefully in Streamlit, perhaps with a warning
                return None 

            fig, ax = plt.subplots(figsize=(8, 6)) # Use subplots for Streamlit
            ax.scatter(dataframe['gross_loss'], dataframe['transferred_loss'])
            ax.set_xlabel('Gross Loss')
            ax.set_ylabel('Transferred Loss (Payout)')
            ax.set_title('Relationship between Gross Loss and Transferred Loss')
            ax.grid(True)
            return fig # Return figure object for Streamlit
        ```

**4.9. Visualizing Aggregated Loss Comparison**
*   **Function**: `plot_aggregated_comparison(aggregated_data)`
*   **Purpose**: Generates a Matplotlib bar chart comparing total gross, transferred, and retained losses.
*   **Streamlit Integration**:
    *   **Display**: Render the Matplotlib figure using `st.pyplot()`.
    *   **Code Reference**:
        ```python
        import pandas as pd
        import matplotlib.pyplot as plt

        def plot_aggregated_comparison(aggregated_data):
            """Generates a bar chart comparing losses."""
            if not aggregated_data:
                # Handle empty data gracefully in Streamlit, perhaps with a warning
                return None

            if isinstance(aggregated_data, dict):
                df = pd.DataFrame({'Loss Category': list(aggregated_data.keys()),
                                     'Total Amount': list(aggregated_data.values())})
            elif isinstance(aggregated_data, pd.DataFrame):
                df = aggregated_data.copy()
            else:
                raise TypeError("Input data must be a dictionary or DataFrame")

            fig, ax = plt.subplots(figsize=(8, 6)) # Use subplots for Streamlit
            ax.bar(df['Loss Category'], df['Total Amount'], color=['red', 'green', 'blue'])
            ax.set_xlabel('Loss Category')
            ax.set_ylabel('Total Amount')
            ax.set_title('Aggregated Loss Comparison')
            fig.tight_layout()
            return fig # Return figure object for Streamlit
        ```

This specification provides a comprehensive guide for developing the Streamlit application, covering user interaction, data processing, and visualization in alignment with the provided requirements and notebook content.
